# TinySeqを作ろうと思った理由。

本文書は、私がTinySeqを作ろうと思った契機や、FORTHを使おうと思った理由を記述します。

## シーケンサが必要になった

仕事でシーケンサが欲しくなった。ないならないでなんとかするのだが、開発中の制御装置がデジタルIN数本/OUT数本でコントロールされ、
その対抗が製品搭載のPLCなので、自分の職場内でシステムが間欠しないのが不満だった。また、製品とは独立でその制御装置をエージングしたい場合に、
制御装置を駆動する方法がなくて困っていた。ならば、その制御装置専用のコントローラをマイクロコントローラで作ればよかろう。

## シーケンサを勉強した

三菱電機はシーケンサ大手である。三菱電機が発行している入門文書[初めてのシーケンサ(入門編)](https://www.mitsubishielectric.com/fa/assist/satellite/data/jy997d41501e.pdf)を見た。リレーとスイッチで構成する回路をコントローラ(というマイコンシステム)内に実現・動作させていること、その回路を「ラダープログラム」として記述しコントローラに突っ込むことが分かった。

さらに、ラダープログラムはシーケンス命令の並びにより表現できることもわかった。

![](img/LadderAndInstructions.jpg)

シーケンス命令を見ると、
```
LD  X001
OR  Y000
ANI X003
OUT Y000
LD  Y000
ANI X006
OUT T1 K30
END
```
という風に、「これアセンブリ言語じゃないか」と思わせる表現と、これを一定時間ごとに繰り返し実行していることが分かった。これならマイクロコントローラを使って実現することはできそうだ。

ただ、テキストベースで書かれたラダープログラムを解釈し実行可能とする仕掛けが必要だった。回路図を変更するたびにファームをビルドし直してダウンロードというのは少し耐えられない。TeraTermでラダープログラムを流し込んで実行可能という形にしたい。何らかの言語実行系が必要と考えた。

## FORTHはどうだろう?

1983年に8080上で実現したFORTHシステムの記事を読んだことがある。あと、PostScriptはFORTHベースであることも聞いていたし、PostScriptプログラムも言語仕様書とCookbookを手に入れ使い倒したこともある。それでなんとなくFORTHのことは知っていた。スタック操作ベースとかはどうでもよくて、

* 命令を定義して増やしてゆくことができること、
* 実行系は辞書(名前からコード列を検索できる表)とスタック2本で実現でき単純であること、
* 実行時には(毎回名前を検索せずに、検索結果の)コード列を直接指した状態で実行するので高速実行できる

ことを覚えていた。これなら今のマイクロコントローラ上で動作するのではないかと考えた。

ネットを探してFORTHの実行処理系や、FORTHを自作しました記事を見つけた。期待通り、数十kB程度でできそうだった。

標準的な実装を見つけることができず、オレオレ実装が多いことも分かった。

FORTH処理系は、最後は機械語を直接実行するものがある。それではマイクロプロセッサに依存してしまう。機械語で記述するプリミティブもそれほど多くなさそう(30～40個ぐらいから)なので、プリミティブを全てC言語で記述した/機械語非依存の処理系を探した。現代のマイクロコントローラならメモリ使用効率・実行効率もそれほど低下しないだろう。ラダープログラムの制御周期も10ms程度でよいらしい。それならば実行効率で最速を追わなくても大丈夫だろうと予想した。

## zForth

Linux上で動作するC言語のみで記述されたFORTH処理系として[zForth](https://github.com/zevv/zForth)を見つけた。これをclone、ビルドして動かしてみると数10kBの範囲に収まっている。ソースコードをざっと見て雰囲気を掴んだ。これなら理解の範囲だ。メモリ操作のみでI/O部分が少ない(putchar/getcharのみ)なので、これならC89/90しかない世界でも十分ビルドできるだろう。シリアルI/OからのReed/Writeを作成すれば、あとはRAM状に配列(数キロバイト程度)一つとスタック(数十個レベル)を2個用意すればよい。辞書も数kB～10kB以下として、RAMが8kB～16kBあれば出来そう。ATmega328Pではしんどそうだな。

## ラダープログラムをFORTH上で表現する

ラダープログラムを記述する際に、シーケンス命令で記述するよりも、ラダー図を
そのまま食わせられた方がよいと考えた。半分ぐらいは私の好みの問題として。ラダー図をASCII ARTとして、例えば、

```
|- X001 ---+---- /X003 ---- ( Y000 ) -|
|- Y000 ---|
|- Y000 -------- /X006 ---- (T1 K30) -|
|---------------------------[ END ]---|
```
という風に書けると楽しそうじゃないか。

FORTHは空白文字以外の文字の列をワードとして、ワード単位で解釈実行する。ならば、上図の `|-`, `X001`, `---+----`, `/X003`, `(`, `Y000`, `)`, ... をFORTHのワードとして実現すればよいという気がした。

実際にはうまくいかないところがある。それは、2本線が1本にマージされるところ
```
---+---
---|
```
で、2行目の `-|`を見つけて初めて1行目の`---+---`とOR結合させるように解釈せねばならない。FORTH言語の解釈方法は逐次的である。このような表現は、大域的に解釈・構文木を構成して解釈というやり方を取らないFORTH言語とは相性が悪い。

しばらく考えて、そこはプログラマに管理してもらうことにしようとした。すなわち、マージ点すべてに共通の番号を付けて、共通の番号のマージ点に入る線の値をOR結合することにした。この場合、上記の例は、
```
---|1
---+1---
```
と書く。右側の引き出し線を2行目に移すことで、それ以後の結線を逐次的解釈の範囲で解釈することができる。実装上は、結線番号ごとに値を保持する変数を一つつ作り、サイクル開始時に0とし、入り線が現れるたびにその変数にORしてゆくようにした。どれか一つの入り線で1(ON)になっていればその結線の値はONとなるからである。

`(Y000)`, `(T1 K30)`についてもカッコを使わない形式に改めた。FORTH言語では、`( ... )`はコメントを表す。ここを変更する手もあるが、カッコで囲まなくても逆ポーランド記法で書けばまとまりとして処理できるし、この程度ならFORTH慣れしていない(私を含む)人々でも対応できると信じて、`Y000`や、`T1 K30`とカッコ無しで書くようにする。

異なる意味を持つワードは異なる表現としておきたいので、スイッチには .a, .bを追加し、`X000.a`, `M000.b`のように表現し、リレーコイルはそのまま `Y000`, `M000`のように表現することとした。

以上をまとめると、今回のTinySeqラダー言語は、
```
|- X001.a -|1
|- Y000.a -+1- X003.b --- Y000   -|
|- Y000.a ---  X006.b --- T1 K30 -|
```
と表現されることになる。ここまで考えて、だいたいイケそうという感触を掴んだ気がした。

## サイクリック演算

ラダープログラムは周期的に実行される。通常のFORTH言語の範囲に周期的な実行の概念はないので、あるワードを定義しておけば、そのワードを周期的に実行するようにFORTHインタプリタを改造する。タイマ割込み処理関数の中で、FORTHインタプリタのeval関数を呼び出すイメージの実装になる。TinySeqでは、当然のごとくワード`ladder`を採用した。

ラダープログラム全体をコロン定義で一つのワードに定義する。
```
: ladder 
  .... (ラダープログラム)
;
```
というプログラム(コロン定義)を起動直後にFORTHインタプリタに読み込ませる。

